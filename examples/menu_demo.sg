import ../tui::{Event, KeyEvent, Resize, Tick, Quit, AppCmdEnum, AppCmd, run, run_capture};
import ../tui/utils::{Frame, buffer_to_string, Buffer};
import ../tui/widgets::{ListState, ListConfig, list_view, list_move, ListStyle, MarkerStyleEnum, MarkerAlignEnum, Marker};
import stdlib/term::{Up, Down, Esc, Enter};

import stdlib/fs;

// ---- App state ----

type AppState = {
    items: string[],
    list: ListState,
    cfg: ListConfig,
};

fn max(a: int, b: int) -> int {
    if a > b { return a; }
    return b;
}

fn min(a: int, b: int) -> int {
    if a < b { return a; }
    return b;
}

// Implement the contract for AppState.
extern<AppState> {
    pub fn count(self: &AppState) -> int {
        return len(self.items) to int;
    }

    pub fn item_text(self: &AppState, index: int) -> string {
        return clone(self.items[index]);
    }
}

// ---- Update / View ----

fn update(st: &mut AppState, ev: Event) -> AppCmd {
    return compare ev {
        KeyEvent(k) => {
            compare k.code {
                Up() => {
                    // viewport = current frame height (unknown here)
                    // v1: assume full screen height minus padding in menu layout.
                    // We'll pass a conservative viewport (e.g. 20) for now; better: store last_frame_h in state.
                    list_move(st.list, st.count(), -1, 20);
                    AppCmdEnum::Redraw;
                };
                Down() => {
                    list_move(st.list, st.count(), 1, 20);
                    AppCmdEnum::Redraw;
                };
                Esc() => AppCmdEnum::Quit;
                Enter() => AppCmdEnum::Quit;
                finally => AppCmdEnum::None;
            };
        }
        Resize(_, _) => AppCmdEnum::Redraw;
        Tick() => AppCmdEnum::None;
        Quit() => AppCmdEnum::Quit;
    };
}

fn view(st: &AppState, fr: &mut Frame) -> nothing {
    let root = fr.area;

    // IMPORTANT: viewport should be derived from actual area height.
    // Here we compute it in view and keep list.scroll stable by making update use a stored viewport later.
    // For now just render; list_view uses inner.h as viewport anyway.

    list_view(st, st.list, st.cfg, fr, root);
}

fn capture(idx: int, buf: &Buffer) -> nothing {
    let text = buffer_to_string(buf);
    let path = f"frames/frame_{idx}.txt";
    let flags_bits: uint = (FS_O::WRITE to uint) | (FS_O::CREATE to uint) | (FS_O::TRUNC to uint);
    let flags: FsOpenFlags = flags_bits to FsOpenFlags;
    let _ = fs.write_string(path, &text, flags);
}

@entrypoint
fn main() -> int {
    let items: Array<string> = ["One", "Two", "Three"];
    let list_config = ListConfig {
        style: ListStyle::new(),
        marker: Marker { text: MarkerStyleEnum::TriangleRight, align: MarkerAlignEnum::Left, width: 3 },
    };
    let mut st: AppState = AppState {
        items = items,
        list = ListState::new(),
        cfg = list_config,
    };

    // Customize: marker / styles â€” edit config structs, no builders.
    // Example: change marker text or width:
    // st.cfg.marker.text = MarkerStyleEnum::TriangleRight;
    // st.cfg.marker.width = 2;

    return run_capture(st, update, view, capture);
}
